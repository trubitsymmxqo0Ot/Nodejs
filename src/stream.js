/*
	Главное концепию stream не путать с концепцией threard, theard - это про работу
	с потоками.

	Наша же концепция нужна для такой вещи: представим, что мы имеем файл 5 гигабайт, 
	читать его полностью будет слишком трудозатратно, а затем его ещё нужно куда-то
	отправить, это будет слишком долгая операция. Однако есть streamReadble и streamWriteble,
	они позволяют маленькими порциями читать или менять файлы, от 64 килабайт, также, 
	нужно понимать, что пример с файлами - это всего-лишь пример, такое может быть в целом
	с чем угодно, что гоняется по сети, мы можем это что-то дробить на мелкие кусочки 
	и таким образом выигрывать в производительности.
*/

const fs = require('fs');
const path = require('path');

const stream = fs.createReadStream(path.resolve(__dirname, 'text.txt'), {/*Тут также множество методов, которые не были раскрыты на уроке*/}); //Кодировку я не указал, а это нужно!

//1 чанк 65кб по дефолту
stream.on('data', (chunk) => {
	console.log(chunk)
})
stream.on('close', () => console.log('Закончили читать'));
stream.on('open', () => console.log('Начали чтение'));
stream.on('error', (e) => console.log(e));

/*
	В целом, эта технология достаточно большая. у неё множество подводных камней, так 
	что сейчас это вводная информация.

	Ещё очень важное замечание, что ошибки нужно всегда обрабатывать, иначе, в случае
	возникновения какой-либо ошибки, все приложение упадет
*/

const writeStream = fs.createWriteStream(path.resolve(__dirname, 'text2.txt'));
for(let i = 0; i < 20; i++){
	writeStream.write(i + '\n');
}
writeStream.close();