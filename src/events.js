const Emmiter = require("events");
const emmiter = new Emmiter();

/*
	events - это очень мощная тема, которая используется практически везде, даже в os, который
	был коммит назад, на строчке cluster.on('exit', под капотом вызывается events.
	В целом, есть много похожих ивентов как из фронта и работают они фактически также.

	Мы создаем свое пользовательское событие с помощью on, где первым аргументом мы
	указываем название события, а вторым аргументом мы передаем callback функцию, которая
	отрабатывает, когда кто-то это событие сгенерировал
*/
emmiter.on(
  "message",
  (
    data,
    second,
    third,
    fouth,
    five /*Можем принимать любое количество аргументов*/
  ) => {
	console.log(`Вы прислали сообщение ${data}`);
	console.log(`Второй аргумент ${second}`)
  }
);


const MESSAGE = process.env.message || ''
if(MESSAGE) {
	emmiter.emit('message', MESSAGE, 123); //Генерирует событие, чтобы оно как раз отработало
} else {
	emmiter.emit('message', 'Вы не указали никакого сообщения');
}

/*
	Как я говорил, такая концепция используется практически везде, т.к. она крайне 
	удобна.

	Она используется:
	при создании http серверов,
	при обмене сообщениями,
	когда нужно сгенерировать какое-то определенное событие на какое-то определенное действие
	в websocket
	в кластеризации

	Праткически любой модуль nodeJs использует событийно-ориентированную модель.

	Также, если мы хотим, чтобы событие отработало только 1 раз, то тогда вместо:
	emmiter.on, нам нужно написать: emmiter.once

	Ещё мы можем удалять все слушатели emmiter.removeAllListeners, можем удалять 
	только 1 событие:
*/
const callback = (data) => {
	console.log(data);
};
emmiter.once('text', callback);
emmiter.removeListener('text', callback);

/*
	Если мы хотим удалить только 1 событие, тогда первым аргументом нужно передать
	имя этого события, а вторым аргументом callback события. Чтобы его несколько раз не 
	переписывать, лучше всего будет вынести такой callback в отдельную переменную
*/


